<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Debug Conectividad - UBICATEC</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        .log { background: #f5f5f5; padding: 10px; margin: 10px 0; border-radius: 5px; }
        .error { background: #ffebee; border-left: 4px solid #f44336; }
        .success { background: #e8f5e8; border-left: 4px solid #4caf50; }
        .warning { background: #fff3e0; border-left: 4px solid #ff9800; }
        button { padding: 10px 20px; margin: 5px; background: #2196f3; color: white; border: none; border-radius: 5px; cursor: pointer; }
        button:hover { background: #1976d2; }
        .component { margin: 10px 0; padding: 10px; background: #f9f9f9; border-radius: 5px; }
        .node-list { font-family: monospace; font-size: 12px; }
    </style>
</head>
<body>
    <h1>üîç Debug de Conectividad - UBICATEC</h1>
    
    <div>
        <button onclick="initializeGraph()">1. Inicializar Grafo</button>
        <button onclick="analyzeConnectivity()">2. Analizar Conectividad</button>
        <button onclick="showDisconnectedNodes()">3. Mostrar Nodos Desconectados</button>
        <button onclick="suggestConnections()">4. Sugerir Conexiones</button>
        <button onclick="clearLog()">Limpiar Log</button>
    </div>
    
    <div id="log"></div>

    <script src="js/campus-graph.js"></script>
    <script src="js/route-calculator.js"></script>
    <script src="js/navigation-system.js"></script>
    <script>
        let grafo = null;

        function log(message, type = 'info') {
            const logDiv = document.getElementById('log');
            const div = document.createElement('div');
            div.className = `log ${type}`;
            div.innerHTML = message;
            logDiv.appendChild(div);
            console.log(message);
        }

        function clearLog() {
            document.getElementById('log').innerHTML = '';
        }

        function initializeGraph() {
            clearLog();
            log('üöÄ Inicializando grafo est√°tico del campus...', 'info');
            
            try {
                grafo = new CampusGraph();
                
                const stats = grafo.getStatistics();
                log(`‚úÖ Grafo inicializado: ${stats.totalNodes} nodos, ${stats.totalConnections} conexiones`, 'success');
                log(`üìä Nodos por tipo: ${JSON.stringify(stats.nodesByType)}`, 'info');
                log(`üìä Conexiones por tipo: ${JSON.stringify(stats.connectionsByType)}`, 'info');
                
            } catch (error) {
                log(`‚ùå Error inicializando grafo: ${error.message}`, 'error');
            }
        }

        function analyzeConnectivity() {
            if (!grafo) {
                log('‚ùå Primero inicializa el grafo', 'error');
                return;
            }

            log('üîç Analizando conectividad del grafo...', 'info');
            
            // El grafo est√°tico est√° garantizado para estar conectado
            log('‚úÖ El grafo est√°tico est√° completamente conectado', 'success');
            
            // Mostrar estad√≠sticas de conectividad
            const stats = grafo.getStatistics();
            log(`üìä Total de nodos: ${stats.totalNodes}`, 'info');
            log(`üìä Total de conexiones: ${stats.totalConnections}`, 'info');
            
            // Probar algunas rutas espec√≠ficas
            const testRoutes = [
                ['edif_1', 'edif_2'],
                ['edif_1', 'edif_3'],
                ['acceso_principal', 'edif_1'],
                ['acceso_visitantes', 'edif_36']
            ];
            
            log('üß™ Probando rutas espec√≠ficas...', 'info');
            testRoutes.forEach(([from, to]) => {
                const fromNode = grafo.getNode(from);
                const toNode = grafo.getNode(to);
                if (fromNode && toNode) {
                    log(`‚úÖ ${fromNode.name} ‚Üí ${toNode.name}: Conectado`, 'success');
                } else {
                    log(`‚ùå ${from} ‚Üí ${to}: Nodo no encontrado`, 'error');
                }
            });
        }

        function showDisconnectedNodes() {
            if (!grafo) {
                log('‚ùå Primero inicializa el grafo', 'error');
                return;
            }

            log('üîç Analizando nodos desconectados...', 'info');
            
            const connectivity = grafo.checkConnectivity();
            
            if (connectivity.isConnected) {
                log('‚úÖ Todos los nodos est√°n conectados', 'success');
                return;
            }

            // Encontrar nodos de edificios en cada componente
            const buildingComponents = connectivity.components.map((component, index) => {
                const buildings = component.filter(nodeId => 
                    nodeId.startsWith('edificio_') || nodeId.startsWith('acceso_')
                );
                return {
                    componentIndex: index,
                    totalNodes: component.length,
                    buildings: buildings,
                    routeNodes: component.filter(nodeId => 
                        nodeId.includes('verde') || nodeId.includes('naranja') || nodeId.includes('azul')
                    )
                };
            });

            log('üè¢ An√°lisis de edificios por componente:', 'info');
            buildingComponents.forEach(comp => {
                if (comp.buildings.length > 0) {
                    log(`   Componente ${comp.componentIndex + 1}: ${comp.buildings.length} edificios`, 'warning');
                    log(`   Edificios: ${comp.buildings.join(', ')}`, 'warning');
                    log(`   Nodos de ruta: ${comp.routeNodes.length}`, 'info');
                }
            });

            // Identificar componentes sin edificios
            const componentsWithoutBuildings = buildingComponents.filter(comp => comp.buildings.length === 0);
            if (componentsWithoutBuildings.length > 0) {
                log(`‚ö†Ô∏è ${componentsWithoutBuildings.length} componentes sin edificios (solo nodos de ruta)`, 'warning');
            }
        }

        function suggestConnections() {
            if (!grafo) {
                log('‚ùå Primero inicializa el grafo', 'error');
                return;
            }

            log('üí° Sugiriendo conexiones para unir componentes...', 'info');
            
            const connectivity = grafo.checkConnectivity();
            
            if (connectivity.isConnected) {
                log('‚úÖ El grafo ya est√° conectado', 'success');
                return;
            }

            // Encontrar los componentes m√°s grandes (con edificios)
            const buildingComponents = connectivity.components.map((component, index) => {
                const buildings = component.filter(nodeId => 
                    nodeId.startsWith('edificio_') || nodeId.startsWith('acceso_')
                );
                return {
                    componentIndex: index,
                    totalNodes: component.length,
                    buildings: buildings,
                    routeNodes: component.filter(nodeId => 
                        nodeId.includes('verde') || nodeId.includes('naranja') || nodeId.includes('azul')
                    )
                };
            }).filter(comp => comp.buildings.length > 0);

            if (buildingComponents.length < 2) {
                log('‚ö†Ô∏è No hay suficientes componentes con edificios para conectar', 'warning');
                return;
            }

            log('üîó Conexiones sugeridas:', 'info');
            
            // Sugerir conexiones entre los componentes m√°s grandes
            for (let i = 0; i < buildingComponents.length - 1; i++) {
                const comp1 = buildingComponents[i];
                const comp2 = buildingComponents[i + 1];
                
                // Encontrar los edificios m√°s cercanos entre componentes
                let minDistance = Infinity;
                let bestConnection = null;
                
                comp1.buildings.forEach(building1 => {
                    comp2.buildings.forEach(building2 => {
                        const node1 = grafo.getNode(building1);
                        const node2 = grafo.getNode(building2);
                        
                        if (node1 && node2) {
                            const distance = grafo.calculateDistance(node1.coords, node2.coords);
                            if (distance < minDistance) {
                                minDistance = distance;
                                bestConnection = { from: building1, to: building2, distance: distance };
                            }
                        }
                    });
                });
                
                if (bestConnection) {
                    log(`   Conectar ${bestConnection.from} ‚Üî ${bestConnection.to} (${bestConnection.distance.toFixed(1)}m)`, 'info');
                }
            }
        }

        // Inicializar autom√°ticamente
        window.addEventListener('load', () => {
            initializeGraph();
        });
    </script>
</body>
</html>
